{"ast":null,"code":"import { __decorate, __param, __metadata, __rest } from 'tslib';\nimport { NgZone, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, Injectable, TemplateRef, ViewContainerRef, Directive, EventEmitter, Input, Output, ViewChild, ElementRef, Component, ChangeDetectionStrategy, forwardRef, NgModule } from '@angular/core';\nimport { BehaviorSubject, Subject } from 'rxjs';\nimport { takeUntil, filter, take } from 'rxjs/operators';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms'; /// <reference path=\"monaco.d.ts\" />\n\nimport * as ɵngcc0 from '@angular/core';\nconst _c0 = [\"editor\"];\nconst _c1 = [\"diffEditor\"];\nconst _c2 = \".monaco-editor[_ngcontent-%COMP%] {\\n  position: absolute;\\n  top: 0;\\n  bottom: 0;\\n  left: 0;\\n  right: 0;\\n\\n}\\n.editor-container[_ngcontent-%COMP%] {\\n\\toverflow: hidden;\\n\\tposition: relative;\\n\\tdisplay: table;\\n\\twidth: 100%;\\n  height: 100%;\\n  min-width: 0;\\n}\";\nconst MONACO_PATH = 'MONACO_PATH';\nlet MonacoEditorLoaderService = /*#__PURE__*/(() => {\n  let MonacoEditorLoaderService = class MonacoEditorLoaderService {\n    constructor(ngZone, monacoPathConfig) {\n      this.ngZone = ngZone;\n      this.monacoPathConfig = monacoPathConfig;\n      this.isMonacoLoaded$ = new BehaviorSubject(false);\n      this._monacoPath = 'assets/monaco-editor/min/vs';\n\n      if (window.monacoEditorAlreadyInitialized) {\n        ngZone.run(() => this.isMonacoLoaded$.next(true));\n        return;\n      }\n\n      window.monacoEditorAlreadyInitialized = true;\n\n      if (this.monacoPathConfig) {\n        this.monacoPath = this.monacoPathConfig;\n      }\n\n      this.loadMonaco();\n    }\n\n    set monacoPath(value) {\n      if (value) {\n        this._monacoPath = value;\n      }\n    }\n\n    loadMonaco() {\n      const onGotAmdLoader = () => {\n        let vsPath = this._monacoPath;\n        window.amdRequire = window.require;\n        const isElectron = !!this.nodeRequire;\n        const isPathUrl = vsPath.includes('http');\n\n        if (isElectron) {\n          // Restore node require in window\n          window.require = this.nodeRequire;\n\n          if (!isPathUrl) {\n            const path = window.require('path');\n\n            vsPath = path.resolve(window.__dirname, this._monacoPath);\n          }\n        }\n\n        window.amdRequire.config({\n          paths: {\n            vs: vsPath\n          }\n        }); // Load monaco\n\n        window.amdRequire(['vs/editor/editor.main'], () => {\n          this.ngZone.run(() => this.isMonacoLoaded$.next(true));\n        }, error => console.error('Error loading monaco-editor: ', error));\n      }; // Check if AMD loader already available\n\n\n      const isAmdLoaderAvailable = !!window.amdRequire;\n\n      if (isAmdLoaderAvailable) {\n        return onGotAmdLoader();\n      }\n\n      const isElectron = !!window.require;\n\n      if (isElectron) {\n        this.addElectronFixScripts();\n        this.nodeRequire = window.require;\n      }\n\n      const loaderScript = document.createElement('script');\n      loaderScript.type = 'text/javascript';\n      loaderScript.src = `${this._monacoPath}/loader.js`;\n      loaderScript.addEventListener('load', onGotAmdLoader);\n      document.body.appendChild(loaderScript);\n    }\n\n    addElectronFixScripts() {\n      const electronFixScript = document.createElement('script'); // workaround monaco-css not understanding the environment\n\n      const inlineScript = document.createTextNode('self.module = undefined;'); // workaround monaco-typescript not understanding the environment\n\n      const inlineScript2 = document.createTextNode('self.process.browser = true;');\n      electronFixScript.appendChild(inlineScript);\n      electronFixScript.appendChild(inlineScript2);\n      document.body.appendChild(electronFixScript);\n    }\n\n  };\n\n  MonacoEditorLoaderService.ɵfac = function MonacoEditorLoaderService_Factory(t) {\n    return new (t || MonacoEditorLoaderService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(MONACO_PATH, 8));\n  };\n\n  MonacoEditorLoaderService.ɵprov = ɵɵdefineInjectable({\n    factory: function MonacoEditorLoaderService_Factory() {\n      return new MonacoEditorLoaderService(ɵɵinject(NgZone), ɵɵinject(\"MONACO_PATH\", 8));\n    },\n    token: MonacoEditorLoaderService,\n    providedIn: \"root\"\n  });\n  MonacoEditorLoaderService = __decorate([__param(1, Optional()), __param(1, Inject(MONACO_PATH)), __metadata(\"design:paramtypes\", [NgZone, String])], MonacoEditorLoaderService);\n  return MonacoEditorLoaderService;\n})();\nlet MonacoEditorLoaderDirective = /*#__PURE__*/(() => {\n  let MonacoEditorLoaderDirective = class MonacoEditorLoaderDirective {\n    constructor(templateRef, viewContainer, monacoEditorLoaderService) {\n      this.templateRef = templateRef;\n      this.viewContainer = viewContainer;\n      this.monacoEditorLoaderService = monacoEditorLoaderService;\n      this.isMonacoLoaded$ = this.monacoEditorLoaderService.isMonacoLoaded$.asObservable();\n      this.destroyed$ = new Subject();\n    }\n\n    ngOnInit() {\n      this.isMonacoLoaded$.pipe(takeUntil(this.destroyed$)).subscribe(loaded => {\n        if (!loaded) {\n          return this.viewContainer.clear();\n        }\n\n        this.viewContainer.createEmbeddedView(this.templateRef);\n      });\n    }\n\n    ngOnDestroy() {\n      this.destroyed$.next();\n      this.destroyed$.complete();\n    }\n\n  };\n\n  MonacoEditorLoaderDirective.ɵfac = function MonacoEditorLoaderDirective_Factory(t) {\n    return new (t || MonacoEditorLoaderDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(MonacoEditorLoaderService));\n  };\n\n  MonacoEditorLoaderDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MonacoEditorLoaderDirective,\n    selectors: [[\"\", \"ngxLoadMonacoEditor\", \"\"]]\n  });\n  MonacoEditorLoaderDirective = __decorate([__metadata(\"design:paramtypes\", [TemplateRef, ViewContainerRef, MonacoEditorLoaderService])], MonacoEditorLoaderDirective);\n  return MonacoEditorLoaderDirective;\n})();\nvar MonacoEditorComponent_1;\nlet MonacoEditorComponent = MonacoEditorComponent_1 = class MonacoEditorComponent {\n  constructor(monacoLoader) {\n    this.monacoLoader = monacoLoader;\n    this.init = new EventEmitter();\n\n    this.propagateChange = _ => {};\n  }\n\n  get model() {\n    return this.editor && this.editor.getModel();\n  }\n\n  get modelMarkers() {\n    return this.model && monaco.editor.getModelMarkers({\n      resource: this.model.uri\n    });\n  }\n\n  ngOnInit() {\n    this.monacoLoader.isMonacoLoaded$.pipe(filter(isLoaded => isLoaded), take(1)).subscribe(() => {\n      this.initEditor();\n    });\n  }\n\n  ngOnChanges(changes) {\n    if (this.editor && changes.options && !changes.options.firstChange) {\n      const _a = changes.options.currentValue,\n            {\n        language: toLanguage,\n        theme: toTheme\n      } = _a,\n            options = __rest(_a, [\"language\", \"theme\"]);\n\n      const {\n        language: fromLanguage,\n        theme: fromTheme\n      } = changes.options.previousValue;\n\n      if (fromLanguage !== toLanguage) {\n        monaco.editor.setModelLanguage(this.editor.getModel(), this.options && this.options.language ? this.options.language : 'text');\n      }\n\n      if (fromTheme !== toTheme) {\n        monaco.editor.setTheme(toTheme);\n      }\n\n      this.editor.updateOptions(options);\n    }\n\n    if (this.editor && changes.uri) {\n      const toUri = changes.uri.currentValue;\n      const fromUri = changes.uri.previousValue;\n\n      if (fromUri && !toUri || !fromUri && toUri || toUri && fromUri && toUri.path !== fromUri.path) {\n        const value = this.editor.getValue();\n\n        if (this.modelUriInstance) {\n          this.modelUriInstance.dispose();\n        }\n\n        let existingModel;\n\n        if (toUri) {\n          existingModel = monaco.editor.getModels().find(model => model.uri.path === toUri.path);\n        }\n\n        this.modelUriInstance = existingModel ? existingModel : monaco.editor.createModel(value, this.options.language || 'text', this.uri);\n        this.editor.setModel(this.modelUriInstance);\n      }\n    }\n  }\n\n  writeValue(value) {\n    this.value = value;\n\n    if (this.editor && value) {\n      this.editor.setValue(value);\n    } else if (this.editor) {\n      this.editor.setValue('');\n    }\n  }\n\n  registerOnChange(fn) {\n    this.propagateChange = fn;\n  }\n\n  registerOnTouched(fn) {\n    this.onTouched = fn;\n  }\n\n  validate() {\n    return !this.parsedError ? null : {\n      monaco: {\n        value: this.parsedError.split('|')\n      }\n    };\n  }\n\n  registerOnValidatorChange(fn) {\n    this.onErrorStatusChange = fn;\n  }\n\n  initEditor() {\n    const options = {\n      value: [this.value].join('\\n'),\n      language: 'text',\n      automaticLayout: true,\n      scrollBeyondLastLine: false,\n      theme: 'vc'\n    };\n    this.editor = monaco.editor.create(this.editorContent.nativeElement, this.options ? Object.assign(Object.assign({}, options), this.options) : options);\n    this.registerEditorListeners();\n    this.init.emit(this.editor);\n  }\n\n  registerEditorListeners() {\n    this.editor.onDidChangeModelContent(() => {\n      this.propagateChange(this.editor.getValue());\n    });\n    this.editor.onDidChangeModelDecorations(() => {\n      const currentParsedError = this.modelMarkers.map(({\n        message\n      }) => message).join('|');\n      const hasValidationStatusChanged = this.parsedError !== currentParsedError;\n\n      if (hasValidationStatusChanged) {\n        this.parsedError = currentParsedError;\n        this.onErrorStatusChange();\n      }\n    });\n    this.editor.onDidBlurEditorText(() => {\n      this.onTouched();\n    });\n  }\n\n  ngOnDestroy() {\n    if (this.editor) {\n      this.editor.dispose();\n    }\n  }\n\n};\n\nMonacoEditorComponent.ɵfac = function MonacoEditorComponent_Factory(t) {\n  return new (t || MonacoEditorComponent)(ɵngcc0.ɵɵdirectiveInject(MonacoEditorLoaderService));\n};\n\nMonacoEditorComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: MonacoEditorComponent,\n  selectors: [[\"ngx-monaco-editor\"]],\n  viewQuery: function MonacoEditorComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(_c0, 7);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.editorContent = _t.first);\n    }\n  },\n  inputs: {\n    options: \"options\",\n    uri: \"uri\"\n  },\n  outputs: {\n    init: \"init\"\n  },\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => MonacoEditorComponent_1),\n    multi: true\n  }, {\n    provide: NG_VALIDATORS,\n    useExisting: forwardRef(() => MonacoEditorComponent_1),\n    multi: true\n  }]), ɵngcc0.ɵɵNgOnChangesFeature],\n  decls: 4,\n  vars: 0,\n  consts: [[\"fxFlex\", \"\", 1, \"editor-container\"], [\"container\", \"\"], [1, \"monaco-editor\"], [\"editor\", \"\"]],\n  template: function MonacoEditorComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\n      ɵngcc0.ɵɵelement(2, \"div\", 2, 3);\n      ɵngcc0.ɵɵelementEnd();\n    }\n  },\n  styles: [_c2],\n  changeDetection: 0\n});\n\nMonacoEditorComponent.ctorParameters = () => [{\n  type: MonacoEditorLoaderService\n}];\n\n__decorate([Input(), __metadata(\"design:type\", Object)], MonacoEditorComponent.prototype, \"options\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], MonacoEditorComponent.prototype, \"uri\", void 0);\n\n__decorate([Output(), __metadata(\"design:type\", EventEmitter)], MonacoEditorComponent.prototype, \"init\", void 0);\n\n__decorate([ViewChild('editor', {\n  static: true\n}), __metadata(\"design:type\", ElementRef)], MonacoEditorComponent.prototype, \"editorContent\", void 0);\n\nMonacoEditorComponent = MonacoEditorComponent_1 = __decorate([__metadata(\"design:paramtypes\", [MonacoEditorLoaderService])], MonacoEditorComponent);\nlet MonacoDiffEditorComponent = /*#__PURE__*/(() => {\n  let MonacoDiffEditorComponent = class MonacoDiffEditorComponent {\n    constructor(monacoLoader) {\n      this.monacoLoader = monacoLoader;\n      this.init = new EventEmitter();\n    }\n\n    ngOnInit() {\n      this.container = this.editorContent.nativeElement;\n      this.monacoLoader.isMonacoLoaded$.pipe(filter(isLoaded => isLoaded), take(1)).subscribe(() => {\n        this.initMonaco();\n      });\n    }\n\n    ngOnChanges(changes) {\n      if (this.editor && (changes.code && !changes.code.firstChange || changes.modified && !changes.modified.firstChange)) {\n        const modified = monaco.editor.createModel(this.modified);\n        const original = monaco.editor.createModel(this.original);\n        this.editor.setModel({\n          original,\n          modified\n        });\n      }\n\n      if (this.editor && changes.options && !changes.options.firstChange) {\n        if (changes.options.previousValue.theme !== changes.options.currentValue.theme) {\n          monaco.editor.setTheme(changes.options.currentValue.theme);\n        }\n\n        this.editor.updateOptions(changes.options.currentValue);\n      }\n    }\n\n    initMonaco() {\n      let opts = {\n        readOnly: true,\n        automaticLayout: true,\n        theme: 'vc'\n      };\n\n      if (this.options) {\n        opts = Object.assign({}, opts, this.options);\n      }\n\n      this.editor = monaco.editor.createDiffEditor(this.container, opts);\n      const original = monaco.editor.createModel(this.original);\n      const modified = monaco.editor.createModel(this.modified);\n      this.editor.setModel({\n        original,\n        modified\n      });\n      this.editor.layout();\n      this.init.emit(this.editor);\n    }\n\n    ngOnDestroy() {\n      if (this.editor) {\n        this.editor.dispose();\n      }\n    }\n\n  };\n\n  MonacoDiffEditorComponent.ɵfac = function MonacoDiffEditorComponent_Factory(t) {\n    return new (t || MonacoDiffEditorComponent)(ɵngcc0.ɵɵdirectiveInject(MonacoEditorLoaderService));\n  };\n\n  MonacoDiffEditorComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MonacoDiffEditorComponent,\n    selectors: [[\"ngx-monaco-diff-editor\"]],\n    viewQuery: function MonacoDiffEditorComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c1, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.editorContent = _t.first);\n      }\n    },\n    inputs: {\n      original: \"original\",\n      modified: \"modified\",\n      options: \"options\"\n    },\n    outputs: {\n      init: \"init\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 4,\n    vars: 0,\n    consts: [[\"fxFlex\", \"\", 1, \"editor-container\"], [\"container\", \"\"], [1, \"monaco-editor\"], [\"diffEditor\", \"\"]],\n    template: function MonacoDiffEditorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\n        ɵngcc0.ɵɵelement(2, \"div\", 2, 3);\n        ɵngcc0.ɵɵelementEnd();\n      }\n    },\n    styles: [_c2],\n    changeDetection: 0\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", String)], MonacoDiffEditorComponent.prototype, \"original\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], MonacoDiffEditorComponent.prototype, \"modified\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], MonacoDiffEditorComponent.prototype, \"options\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MonacoDiffEditorComponent.prototype, \"init\", void 0);\n\n  __decorate([ViewChild('diffEditor', {\n    static: true\n  }), __metadata(\"design:type\", ElementRef)], MonacoDiffEditorComponent.prototype, \"editorContent\", void 0);\n\n  MonacoDiffEditorComponent = __decorate([__metadata(\"design:paramtypes\", [MonacoEditorLoaderService])], MonacoDiffEditorComponent);\n  return MonacoDiffEditorComponent;\n})();\nlet MonacoEditorModule = /*#__PURE__*/(() => {\n  let MonacoEditorModule = class MonacoEditorModule {};\n\n  MonacoEditorModule.ɵfac = function MonacoEditorModule_Factory(t) {\n    return new (t || MonacoEditorModule)();\n  };\n\n  MonacoEditorModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MonacoEditorModule\n  });\n  MonacoEditorModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[]]\n  });\n  return MonacoEditorModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MonacoEditorModule, {\n    declarations: [MonacoEditorLoaderDirective, MonacoEditorComponent, MonacoDiffEditorComponent],\n    exports: [MonacoEditorLoaderDirective, MonacoEditorComponent, MonacoDiffEditorComponent]\n  });\n})();\n/*\n * Public API Surface of materia-monaco-editor-lib\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { MONACO_PATH, MonacoDiffEditorComponent, MonacoEditorComponent, MonacoEditorLoaderDirective, MonacoEditorLoaderService, MonacoEditorModule }; //# sourceMappingURL=materia-ui-ngx-monaco-editor.js.map","map":null,"metadata":{},"sourceType":"module"}