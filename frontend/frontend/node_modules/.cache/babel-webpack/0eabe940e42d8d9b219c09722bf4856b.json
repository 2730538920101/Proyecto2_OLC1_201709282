{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-dispatch'), require('d3-transition'), require('d3-timer'), require('d3-interpolate'), require('d3-zoom'), require('viz.js/viz'), require('d3-format'), require('d3-path')) : typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-dispatch', 'd3-transition', 'd3-timer', 'd3-interpolate', 'd3-zoom', 'viz.js/viz', 'd3-format', 'd3-path'], factory) : factory(global['d3-graphviz'] = {}, global.d3, global.d3, global.d3, global.d3, global.d3, global.d3, global.Viz, global.d3, global.d3);\n})(this, function (exports, d3, d3Dispatch, d3Transition, d3Timer, d3Interpolate, d3Zoom, Viz, d3Format, d3Path) {\n  'use strict';\n\n  Viz = Viz && Viz.hasOwnProperty('default') ? Viz['default'] : Viz;\n\n  function extractElementData(element) {\n    var datum = {};\n    var tag = element.node().nodeName;\n    datum.tag = tag;\n\n    if (tag == '#text') {\n      datum.text = element.text();\n    } else if (tag == '#comment') {\n      datum.comment = element.text();\n    }\n\n    datum.attributes = {};\n    var attributes = element.node().attributes;\n\n    if (attributes) {\n      for (var i = 0; i < attributes.length; i++) {\n        var attribute = attributes[i];\n        var name = attribute.name;\n        var value = attribute.value;\n        datum.attributes[name] = value;\n      }\n    }\n\n    var transform = element.node().transform;\n\n    if (transform && transform.baseVal.numberOfItems != 0) {\n      var matrix = transform.baseVal.consolidate().matrix;\n      datum.translation = {\n        x: matrix.e,\n        y: matrix.f\n      };\n      datum.scale = matrix.a;\n    }\n\n    if (tag == 'ellipse') {\n      datum.center = {\n        x: datum.attributes.cx,\n        y: datum.attributes.cy\n      };\n    }\n\n    if (tag == 'polygon') {\n      var points = element.attr('points').split(' ');\n      var x = points.map(function (p) {\n        return p.split(',')[0];\n      });\n      var y = points.map(function (p) {\n        return p.split(',')[1];\n      });\n      var xmin = Math.min.apply(null, x);\n      var xmax = Math.max.apply(null, x);\n      var ymin = Math.min.apply(null, y);\n      var ymax = Math.max.apply(null, y);\n      var bbox = {\n        x: xmin,\n        y: ymin,\n        width: xmax - xmin,\n        height: ymax - ymin\n      };\n      datum.bbox = bbox;\n      datum.center = {\n        x: (xmin + xmax) / 2,\n        y: (ymin + ymax) / 2\n      };\n    }\n\n    if (tag == 'path') {\n      var d = element.attr('d');\n      var points = d.split(/[A-Z ]/);\n      points.shift();\n      var x = points.map(function (p) {\n        return +p.split(',')[0];\n      });\n      var y = points.map(function (p) {\n        return +p.split(',')[1];\n      });\n      var xmin = Math.min.apply(null, x);\n      var xmax = Math.max.apply(null, x);\n      var ymin = Math.min.apply(null, y);\n      var ymax = Math.max.apply(null, y);\n      var bbox = {\n        x: xmin,\n        y: ymin,\n        width: xmax - xmin,\n        height: ymax - ymin\n      };\n      datum.bbox = bbox;\n      datum.center = {\n        x: (xmin + xmax) / 2,\n        y: (ymin + ymax) / 2\n      };\n      datum.totalLength = element.node().getTotalLength();\n    }\n\n    if (tag == 'text') {\n      datum.center = {\n        x: element.attr('x'),\n        y: element.attr('y')\n      };\n    }\n\n    if (tag == '#text') {\n      datum.text = element.text();\n    } else if (tag == '#comment') {\n      datum.comment = element.text();\n    }\n\n    return datum;\n  }\n\n  function extractAllElementsData(element) {\n    var datum = extractElementData(element);\n    datum.children = [];\n    var children = d3.selectAll(element.node().childNodes);\n    children.each(function () {\n      var childData = extractAllElementsData(d3.select(this));\n      childData.parent = datum;\n      datum.children.push(childData);\n    });\n    return datum;\n  }\n\n  function createElement(data) {\n    if (data.tag == '#text') {\n      return document.createTextNode(\"\");\n    } else if (data.tag == '#comment') {\n      return document.createComment(data.comment);\n    } else {\n      return document.createElementNS('http://www.w3.org/2000/svg', data.tag);\n    }\n  }\n\n  function createElementWithAttributes(data) {\n    var elementNode = createElement(data);\n    var element = d3.select(elementNode);\n    var attributes = data.attributes;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = Object.keys(attributes)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var attributeName = _step.value;\n        var attributeValue = attributes[attributeName];\n        element.attr(attributeName, attributeValue);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return elementNode;\n  }\n\n  function replaceElement(element, data) {\n    var parent = d3.select(element.node().parentNode);\n    var newElementNode = createElementWithAttributes(data);\n    var newElement = parent.insert(function () {\n      return newElementNode;\n    }, function () {\n      return element.node();\n    });\n    element.remove();\n    return newElement;\n  }\n\n  function insertElementData(element, datum) {\n    element.datum(datum);\n    element.data([datum], function (d) {\n      return d.key;\n    });\n  }\n\n  function insertAllElementsData(element, datum) {\n    insertElementData(element, datum);\n    var children = d3.selectAll(element.node().childNodes);\n    children.each(function (d, i) {\n      insertAllElementsData(d3.select(this), datum.children[i]);\n    });\n  }\n\n  function insertChildren(element, index) {\n    var children = element.selectAll(function () {\n      return element.node().childNodes;\n    });\n    children = children.data(function (d) {\n      return d.children;\n    }, function (d) {\n      return d.tag + '-' + index;\n    });\n    var childrenEnter = children.enter().append(function (d) {\n      return createElement(d);\n    });\n    var childrenExit = children.exit();\n    childrenExit = childrenExit.remove();\n    children = childrenEnter.merge(children);\n    var childTagIndexes = {};\n    children.each(function (childData) {\n      var childTag = childData.tag;\n\n      if (childTagIndexes[childTag] == null) {\n        childTagIndexes[childTag] = 0;\n      }\n\n      var childIndex = childTagIndexes[childTag]++;\n      attributeElement.call(this, childData, childIndex);\n    });\n  }\n\n  function attributeElement(data) {\n    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var element = d3.select(this);\n    var tag = data.tag;\n    var attributes = data.attributes;\n    var currentAttributes = element.node().attributes;\n\n    if (currentAttributes) {\n      for (var i = 0; i < currentAttributes.length; i++) {\n        var currentAttribute = currentAttributes[i];\n        var name = currentAttribute.name;\n\n        if (name.split(':')[0] != 'xmlns' && currentAttribute.namespaceURI) {\n          var namespaceURIParts = currentAttribute.namespaceURI.split('/');\n          var namespace = namespaceURIParts[namespaceURIParts.length - 1];\n          name = namespace + ':' + name;\n        }\n\n        if (!(name in attributes)) {\n          attributes[name] = null;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = Object.keys(attributes)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var attributeName = _step2.value;\n        element.attr(attributeName, attributes[attributeName]);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    if (data.text) {\n      element.text(data.text);\n    }\n\n    insertChildren(element, index);\n  }\n\n  function shallowCopyObject(obj) {\n    return Object.assign({}, obj);\n  }\n\n  function roundTo4Decimals(x) {\n    return Math.round(x * 10000.0) / 10000.0;\n  }\n\n  var zoom$1 = function (enable) {\n    this._options.zoom = enable;\n\n    if (this._options.zoom && !this._zoomBehavior) {\n      createZoomBehavior.call(this);\n    }\n\n    return this;\n  };\n\n  function createZoomBehavior() {\n    function zoomed() {\n      var g = d3.select(svg.node().querySelector(\"g\"));\n      g.attr('transform', d3.event.transform);\n    }\n\n    var root = this._selection;\n    var svg = d3.select(root.node().querySelector(\"svg\"));\n\n    if (svg.size() == 0) {\n      return this;\n    }\n\n    this._zoomSelection = svg;\n    var zoomBehavior = d3Zoom.zoom().scaleExtent(this._options.zoomScaleExtent).translateExtent(this._options.zoomTranslateExtent).interpolate(d3Interpolate.interpolate).on(\"zoom\", zoomed);\n    this._zoomBehavior = zoomBehavior;\n    var g = d3.select(svg.node().querySelector(\"g\"));\n    svg.call(zoomBehavior);\n\n    if (!this._active) {\n      translateZoomBehaviorTransform.call(this, g);\n    }\n\n    this._originalTransform = d3Zoom.zoomTransform(svg.node());\n    return this;\n  }\n\n  function getTranslatedZoomTransform(selection$$1) {\n    // Get the current zoom transform for the top level svg and\n    // translate it uniformly with the given selection, using the\n    // difference between the translation specified in the selection's\n    // data and it's saved previous translation. The selection is\n    // normally the top level g element of the graph.\n    var oldTranslation = this._translation;\n    var oldScale = this._scale;\n    var newTranslation = selection$$1.datum().translation;\n    var newScale = selection$$1.datum().scale;\n    var t = d3Zoom.zoomTransform(this._zoomSelection.node());\n\n    if (oldTranslation) {\n      t = t.scale(1 / oldScale);\n      t = t.translate(-oldTranslation.x, -oldTranslation.y);\n    }\n\n    t = t.translate(newTranslation.x, newTranslation.y);\n    t = t.scale(newScale);\n    return t;\n  }\n\n  function translateZoomBehaviorTransform(selection$$1) {\n    // Translate the current zoom transform for the top level svg\n    // uniformly with the given selection, using the difference\n    // between the translation specified in the selection's data and\n    // it's saved previous translation. The selection is normally the\n    // top level g element of the graph.\n    this._zoomBehavior.transform(this._zoomSelection, getTranslatedZoomTransform.call(this, selection$$1)); // Save the selections's new translation and scale.\n\n\n    this._translation = selection$$1.datum().translation;\n    this._scale = selection$$1.datum().scale; // Set the original zoom transform to the translation and scale specified in\n    // the selection's data.\n\n    this._originalTransform = d3Zoom.zoomIdentity.translate(selection$$1.datum().translation.x, selection$$1.datum().translation.y).scale(selection$$1.datum().scale);\n  }\n\n  function resetZoom(transition$$1) {\n    // Reset the zoom transform to the original zoom transform.\n    var selection$$1 = this._zoomSelection;\n\n    if (transition$$1) {\n      selection$$1 = selection$$1.transition(transition$$1);\n    }\n\n    selection$$1.call(this._zoomBehavior.transform, this._originalTransform);\n    return this;\n  }\n\n  function zoomScaleExtent(extent) {\n    this._options.zoomScaleExtent = extent;\n    return this;\n  }\n\n  function zoomTranslateExtent(extent) {\n    this._options.zoomTranslateExtent = extent;\n    return this;\n  }\n\n  function zoomBehavior() {\n    return this._zoomBehavior || null;\n  }\n\n  function zoomSelection() {\n    return this._zoomSelection || null;\n  }\n\n  function pathTween(points, d1) {\n    return function () {\n      var pointInterpolators = points.map(function (p) {\n        return d3Interpolate.interpolate([p[0][0], p[0][1]], [p[1][0], p[1][1]]);\n      });\n      return function (t) {\n        return t < 1 ? \"M\" + pointInterpolators.map(function (p) {\n          return p(t);\n        }).join(\"L\") : d1;\n      };\n    };\n  }\n\n  function pathTweenPoints(node, d1, precision, precisionIsRelative) {\n    var path0 = node;\n    var path1 = path0.cloneNode();\n    var n0 = path0.getTotalLength();\n    var n1 = (path1.setAttribute(\"d\", d1), path1).getTotalLength(); // Uniform sampling of distance based on specified precision.\n\n    var distances = [0];\n    var i = 0;\n    var dt = precisionIsRelative ? precision : precision / Math.max(n0, n1);\n\n    while ((i += dt) < 1) {\n      distances.push(i);\n    }\n\n    distances.push(1); // Compute point-interpolators at each distance.\n\n    var points = distances.map(function (t) {\n      var p0 = path0.getPointAtLength(t * n0);\n      var p1 = path1.getPointAtLength(t * n1);\n      return [[p0.x, p0.y], [p1.x, p1.y]];\n    });\n    return points;\n  }\n\n  var data = function () {\n    return this._data || null;\n  };\n\n  function isEdgeElementParent(datum) {\n    return datum.attributes.class == 'edge' || datum.tag == 'a' && datum.parent.tag == 'g' && datum.parent.parent.attributes.class == 'edge';\n  }\n\n  function isEdgeElement(datum) {\n    return datum.parent && isEdgeElementParent(datum.parent);\n  }\n\n  function getEdgeGroup(datum) {\n    if (datum.parent.attributes.class == 'edge') {\n      return datum.parent;\n    } else {\n      // datum.parent.tag == 'g' && datum.parent.parent.tag == 'g' && datum.parent.parent.parent.attributes.class == 'edge'\n      return datum.parent.parent.parent;\n    }\n  }\n\n  function getEdgeTitle(datum) {\n    return getEdgeGroup(datum).children.find(function (e) {\n      return e.tag == 'title';\n    });\n  }\n\n  var render = function (callback) {\n    if (this._busy) {\n      this._queue.push(this.render.bind(this, callback));\n\n      return this;\n    }\n\n    this._dispatch.call('renderStart', this);\n\n    if (this._transitionFactory) {\n      d3Timer.timeout(function () {\n        // Decouple from time spent. See https://github.com/d3/d3-timer/issues/27\n        this._transition = d3Transition.transition(this._transitionFactory());\n\n        _render.call(this, callback);\n      }.bind(this), 0);\n    } else {\n      _render.call(this, callback);\n    }\n\n    return this;\n  };\n\n  function _render(callback) {\n    var transitionInstance = this._transition;\n    var fade = this._options.fade && transitionInstance != null;\n    var tweenPaths = this._options.tweenPaths;\n    var tweenShapes = this._options.tweenShapes;\n    var convertEqualSidedPolygons = this._options.convertEqualSidedPolygons;\n    var growEnteringEdges = this._options.growEnteringEdges && transitionInstance != null;\n    var attributer = this._attributer;\n    var graphvizInstance = this;\n\n    function insertChildren(element) {\n      var children = element.selectAll(function () {\n        return element.node().childNodes;\n      });\n      children = children.data(function (d) {\n        return d.children;\n      }, function (d) {\n        return d.key;\n      });\n      var childrenEnter = children.enter().append(function (d) {\n        var element = createElement(d);\n\n        if (d.tag == '#text' && fade) {\n          element.nodeValue = d.text;\n        }\n\n        return element;\n      });\n\n      if (fade || growEnteringEdges && isEdgeElementParent(element.datum())) {\n        var childElementsEnter = childrenEnter.filter(function (d) {\n          return d.tag[0] == '#' ? null : this;\n        }).each(function (d) {\n          var childEnter = d3.select(this);\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = Object.keys(d.attributes)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var attributeName = _step.value;\n              var attributeValue = d.attributes[attributeName];\n              childEnter.attr(attributeName, attributeValue);\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        });\n        childElementsEnter.filter(function (d) {\n          return d.tag == 'svg' || d.tag == 'g' ? null : this;\n        }).style(\"opacity\", 0.0);\n      }\n\n      var childrenExit = children.exit();\n\n      if (attributer) {\n        childrenExit.each(attributer);\n      }\n\n      if (transitionInstance) {\n        childrenExit = childrenExit.transition(transitionInstance);\n\n        if (fade) {\n          childrenExit.filter(function (d) {\n            return d.tag[0] == '#' ? null : this;\n          }).style(\"opacity\", 0.0);\n        }\n      }\n\n      childrenExit = childrenExit.remove();\n      children = childrenEnter.merge(children);\n      children.each(attributeElement$$1);\n    }\n\n    function attributeElement$$1(data$$1) {\n      var element = d3.select(this);\n\n      if (data$$1.tag == \"svg\") {\n        var options = graphvizInstance._options;\n\n        if (options.width != null || options.height != null) {\n          var width = options.width;\n          var height = options.height;\n\n          if (width == null) {\n            width = data$$1.attributes.width.replace('pt', '') * 4 / 3;\n          } else {\n            element.attr(\"width\", width);\n            data$$1.attributes.width = width;\n          }\n\n          if (height == null) {\n            height = data$$1.attributes.height.replace('pt', '') * 4 / 3;\n          } else {\n            element.attr(\"height\", height);\n            data$$1.attributes.height = height;\n          }\n\n          if (!options.fit) {\n            element.attr(\"viewBox\", \"0 0 \" + width * 3 / 4 / options.scale + \" \" + height * 3 / 4 / options.scale);\n            data$$1.attributes.viewBox = \"0 0 \" + width * 3 / 4 / options.scale + \" \" + height * 3 / 4 / options.scale;\n          }\n        }\n\n        if (options.scale != 1 && (options.fit || options.width == null && options.height == null)) {\n          width = data$$1.attributes.viewBox.split(' ')[2];\n          height = data$$1.attributes.viewBox.split(' ')[3];\n          element.attr(\"viewBox\", \"0 0 \" + width / options.scale + \" \" + height / options.scale);\n          data$$1.attributes.viewBox = \"0 0 \" + width / options.scale + \" \" + height / options.scale;\n        }\n      }\n\n      if (attributer) {\n        element.each(attributer);\n      }\n\n      var tag = data$$1.tag;\n      var attributes = data$$1.attributes;\n      var currentAttributes = element.node().attributes;\n\n      if (currentAttributes) {\n        for (var i = 0; i < currentAttributes.length; i++) {\n          var currentAttribute = currentAttributes[i];\n          var name = currentAttribute.name;\n\n          if (name.split(':')[0] != 'xmlns' && currentAttribute.namespaceURI) {\n            var namespaceURIParts = currentAttribute.namespaceURI.split('/');\n            var namespace = namespaceURIParts[namespaceURIParts.length - 1];\n            name = namespace + ':' + name;\n          }\n\n          if (!(name in attributes)) {\n            attributes[name] = null;\n          }\n        }\n      }\n\n      var convertShape = false;\n      var convertPrevShape = false;\n\n      if (tweenShapes && transitionInstance) {\n        if ((this.nodeName == 'polygon' || this.nodeName == 'ellipse') && data$$1.alternativeOld) {\n          convertPrevShape = true;\n        }\n\n        if ((tag == 'polygon' || tag == 'ellipse') && data$$1.alternativeNew) {\n          convertShape = true;\n        }\n\n        if (this.nodeName == 'polygon' && tag == 'polygon') {\n          var prevData = extractElementData(element);\n          var prevPoints = prevData.attributes.points;\n\n          if (!convertEqualSidedPolygons) {\n            var nPrevPoints = prevPoints.split(' ').length;\n            var points = data$$1.attributes.points;\n            var nPoints = points.split(' ').length;\n\n            if (nPoints == nPrevPoints) {\n              convertShape = false;\n              convertPrevShape = false;\n            }\n          }\n        }\n\n        if (convertPrevShape) {\n          var prevPathData = data$$1.alternativeOld;\n          var pathElement = replaceElement(element, prevPathData);\n          pathElement.data([data$$1], function () {\n            return data$$1.key;\n          });\n          element = pathElement;\n        }\n\n        if (convertShape) {\n          var newPathData = data$$1.alternativeNew;\n          tag = 'path';\n          attributes = newPathData.attributes;\n        }\n      }\n\n      var elementTransition = element;\n\n      if (transitionInstance) {\n        elementTransition = elementTransition.transition(transitionInstance);\n\n        if (fade) {\n          elementTransition.filter(function (d) {\n            return d.tag[0] == '#' ? null : this;\n          }).style(\"opacity\", 1.0);\n        }\n\n        elementTransition.filter(function (d) {\n          return d.tag[0] == '#' ? null : this;\n        }).on(\"end\", function () {\n          d3.select(this).attr('style', null);\n        });\n      }\n\n      var growThisPath = growEnteringEdges && tag == 'path' && data$$1.offset;\n\n      if (growThisPath) {\n        var totalLength = data$$1.totalLength;\n        element.attr(\"stroke-dasharray\", totalLength + \" \" + totalLength).attr(\"stroke-dashoffset\", totalLength).attr('transform', 'translate(' + data$$1.offset.x + ',' + data$$1.offset.y + ')');\n        attributes[\"stroke-dashoffset\"] = 0;\n        attributes['transform'] = 'translate(0,0)';\n        elementTransition.attr(\"stroke-dashoffset\", attributes[\"stroke-dashoffset\"]).attr('transform', attributes['transform']).on(\"start\", function () {\n          d3.select(this).style('opacity', null);\n        }).on(\"end\", function () {\n          d3.select(this).attr('stroke-dashoffset', null).attr('stroke-dasharray', null).attr('transform', null);\n        });\n      }\n\n      var moveThisPolygon = growEnteringEdges && tag == 'polygon' && isEdgeElement(data$$1) && data$$1.offset;\n\n      if (moveThisPolygon) {\n        var edgePath = d3.select(element.node().parentNode.querySelector(\"path\"));\n        var p0 = edgePath.node().getPointAtLength(0);\n        var p1 = edgePath.node().getPointAtLength(data$$1.totalLength);\n        var p2 = edgePath.node().getPointAtLength(data$$1.totalLength - 1);\n        var angle1 = Math.atan2(p1.y - p2.y, p1.x - p2.x) * 180 / Math.PI;\n        var x = p0.x - p1.x + data$$1.offset.x;\n        var y = p0.y - p1.y + data$$1.offset.y;\n        element.attr('transform', 'translate(' + x + ',' + y + ')');\n        elementTransition.attrTween(\"transform\", function () {\n          return function (t) {\n            var p = edgePath.node().getPointAtLength(data$$1.totalLength * t);\n            var p2 = edgePath.node().getPointAtLength(data$$1.totalLength * t + 1);\n            var angle = Math.atan2(p2.y - p.y, p2.x - p.x) * 180 / Math.PI - angle1;\n            x = p.x - p1.x + data$$1.offset.x * (1 - t);\n            y = p.y - p1.y + data$$1.offset.y * (1 - t);\n            return 'translate(' + x + ',' + y + ') rotate(' + angle + ' ' + p1.x + ' ' + p1.y + ')';\n          };\n        }).on(\"start\", function () {\n          d3.select(this).style('opacity', null);\n        }).on(\"end\", function () {\n          d3.select(this).attr('transform', null);\n        });\n      }\n\n      var tweenThisPath = tweenPaths && transitionInstance && tag == 'path' && element.attr('d') != null;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = Object.keys(attributes)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var attributeName = _step2.value;\n          var attributeValue = attributes[attributeName];\n\n          if (tweenThisPath && attributeName == 'd') {\n            var points = (data$$1.alternativeOld || data$$1).points;\n\n            if (points) {\n              elementTransition.attrTween(\"d\", pathTween(points, attributeValue));\n            }\n          } else {\n            if (attributeName == 'transform' && data$$1.translation) {\n              if (transitionInstance) {\n                var onEnd = elementTransition.on(\"end\");\n                elementTransition.on(\"start\", function () {\n                  if (graphvizInstance._zoomBehavior) {\n                    // Update the transform to transition to, just before the transition starts\n                    // in order to catch changes between the transition scheduling to its start.\n                    elementTransition.tween(\"attr.transform\", function () {\n                      var node = this;\n                      return function (t) {\n                        node.setAttribute(\"transform\", d3Interpolate.interpolateTransformSvg(d3Zoom.zoomTransform(graphvizInstance._zoomSelection.node()).toString(), getTranslatedZoomTransform.call(graphvizInstance, element).toString())(t));\n                      };\n                    });\n                  }\n                }).on(\"end\", function () {\n                  onEnd.call(this); // Update the zoom transform to the new translated transform\n\n                  if (graphvizInstance._zoomBehavior) {\n                    translateZoomBehaviorTransform.call(graphvizInstance, element);\n                  }\n                });\n              } else {\n                if (graphvizInstance._zoomBehavior) {\n                  // Update the transform attribute to set with the current pan translation\n                  attributeValue = getTranslatedZoomTransform.call(graphvizInstance, element).toString();\n                }\n              }\n            }\n\n            elementTransition.attr(attributeName, attributeValue);\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      if (convertShape) {\n        elementTransition.on(\"end\", function (d, i, nodes) {\n          pathElement = d3.select(this);\n          var newElement = replaceElement(pathElement, d);\n          newElement.data([d], function () {\n            return d.key;\n          });\n        });\n      }\n\n      if (data$$1.text) {\n        elementTransition.text(data$$1.text);\n      }\n\n      insertChildren(element);\n    }\n\n    var root = this._selection;\n\n    if (transitionInstance != null) {\n      // Ensure original SVG shape elements are restored after transition before rendering new graph\n      var jobs = this._jobs;\n\n      if (graphvizInstance._active) {\n        jobs.push(null);\n        return this;\n      } else {\n        root.transition(transitionInstance).transition().duration(0).on(\"end\", function () {\n          graphvizInstance._active = false;\n\n          if (jobs.length != 0) {\n            jobs.shift();\n            graphvizInstance.render();\n          }\n        });\n        this._active = true;\n      }\n    }\n\n    if (transitionInstance != null) {\n      root.transition(transitionInstance).on(\"start\", function () {\n        graphvizInstance._dispatch.call('transitionStart', graphvizInstance);\n      }).on(\"end\", function () {\n        graphvizInstance._dispatch.call('transitionEnd', graphvizInstance);\n      }).transition().duration(0).on(\"start\", function () {\n        graphvizInstance._dispatch.call('restoreEnd', graphvizInstance);\n\n        graphvizInstance._dispatch.call('end', graphvizInstance);\n\n        if (callback) {\n          callback.call(graphvizInstance);\n        }\n      });\n    }\n\n    var data$$1 = this._data;\n    var svg = root.selectAll(\"svg\").data([data$$1], function (d) {\n      return d.key;\n    });\n    svg = svg.enter().append(\"svg\").merge(svg);\n    attributeElement$$1.call(svg.node(), data$$1);\n\n    if (this._options.zoom && !this._zoomBehavior) {\n      createZoomBehavior.call(this);\n    }\n\n    graphvizInstance._dispatch.call('renderEnd', graphvizInstance);\n\n    if (transitionInstance == null) {\n      this._dispatch.call('end', this);\n\n      if (callback) {\n        callback.call(this);\n      }\n    }\n\n    return this;\n  }\n\n  function convertToPathData(originalData, guideData) {\n    if (originalData.tag == 'polygon') {\n      var newData = shallowCopyObject(originalData);\n      newData.tag = 'path';\n      var originalAttributes = originalData.attributes;\n      var newAttributes = shallowCopyObject(originalAttributes);\n      var newPointsString = originalAttributes.points;\n\n      if (guideData.tag == 'polygon') {\n        var bbox = originalData.bbox;\n        bbox.cx = bbox.x + bbox.width / 2;\n        bbox.cy = bbox.y + bbox.height / 2;\n        var pointsString = originalAttributes.points;\n        var pointStrings = pointsString.split(' ');\n        var normPoints = pointStrings.map(function (p) {\n          var xy = p.split(',');\n          return [xy[0] - bbox.cx, xy[1] - bbox.cy];\n        });\n        var x0 = normPoints[normPoints.length - 1][0];\n        var y0 = normPoints[normPoints.length - 1][1];\n\n        for (var i = 0; i < normPoints.length; i++, x0 = x1, y0 = y1) {\n          var x1 = normPoints[i][0];\n          var y1 = normPoints[i][1];\n          var dx = x1 - x0;\n          var dy = y1 - y0;\n\n          if (dy == 0) {\n            continue;\n          } else {\n            var x2 = x0 - y0 * dx / dy;\n          }\n\n          if (0 <= x2 && x2 < Infinity && (x0 <= x2 && x2 <= x1 || x1 <= x2 && x2 <= x0)) {\n            break;\n          }\n        }\n\n        var newPointStrings = [[bbox.cx + x2, bbox.cy + 0].join(',')];\n        newPointStrings = newPointStrings.concat(pointStrings.slice(i));\n        newPointStrings = newPointStrings.concat(pointStrings.slice(0, i));\n        newPointsString = newPointStrings.join(' ');\n      }\n\n      newAttributes['d'] = 'M' + newPointsString + 'z';\n      delete newAttributes.points;\n      newData.attributes = newAttributes;\n    } else\n      /* if (originalData.tag == 'ellipse') */\n      {\n        var newData = shallowCopyObject(originalData);\n        newData.tag = 'path';\n        var originalAttributes = originalData.attributes;\n        var newAttributes = shallowCopyObject(originalAttributes);\n        var cx = originalAttributes.cx;\n        var cy = originalAttributes.cy;\n        var rx = originalAttributes.rx;\n        var ry = originalAttributes.ry;\n\n        if (guideData.tag == 'polygon') {\n          var bbox = guideData.bbox;\n          bbox.cx = bbox.x + bbox.width / 2;\n          bbox.cy = bbox.y + bbox.height / 2;\n          var p = guideData.attributes.points.split(' ')[0].split(',');\n          var sx = p[0];\n          var sy = p[1];\n          var dx = sx - bbox.cx;\n          var dy = sy - bbox.cy;\n          var l = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          var cosA = dx / l;\n          var sinA = -dy / l;\n        } else {\n          // if (guideData.tag == 'path') {\n          // FIXME: add support for getting start position from path\n          var cosA = 1;\n          var sinA = 0;\n        }\n\n        var x1 = rx * cosA;\n        var y1 = -ry * sinA;\n        var x2 = rx * -cosA;\n        var y2 = -ry * -sinA;\n        var dx = x2 - x1;\n        var dy = y2 - y1;\n        newAttributes['d'] = 'M ' + cx + ' ' + cy + ' m ' + x1 + ',' + y1 + ' a ' + rx + ',' + ry + ' 0 1,0 ' + dx + ',' + dy + ' a ' + rx + ',' + ry + ' 0 1,0 ' + -dx + ',' + -dy + 'z';\n        delete newAttributes.cx;\n        delete newAttributes.cy;\n        delete newAttributes.rx;\n        delete newAttributes.ry;\n        newData.attributes = newAttributes;\n      }\n\n    return newData;\n  }\n\n  function translatePointsAttribute(pointsString, x, y) {\n    var pointStrings = pointsString.split(' ');\n    var points = pointStrings.map(function (p) {\n      return p.split(',');\n    });\n    var points = pointStrings.map(function (p) {\n      return [roundTo4Decimals(+x + +p.split(',')[0]), roundTo4Decimals(+y + +p.split(',')[1])];\n    });\n    var pointStrings = points.map(function (p) {\n      return p.join(',');\n    });\n    var pointsString = pointStrings.join(' ');\n    pointsString = pointsString.replace(/-0\\./g, '-.').replace(/ 0\\./g, ' .');\n    return pointsString;\n  }\n\n  function translateDAttribute(d, x, y) {\n    var pointStrings = d.split(/[A-Z ]/);\n    pointStrings.shift();\n    var commands = d.split(/[^[A-Z ]+/);\n    var points = pointStrings.map(function (p) {\n      return p.split(',');\n    });\n    var points = pointStrings.map(function (p) {\n      return [roundTo4Decimals(+x + +p.split(',')[0]), roundTo4Decimals(+y + +p.split(',')[1])];\n    });\n    var pointStrings = points.map(function (p) {\n      return p.join(',');\n    });\n    d = commands.reduce(function (arr, v, i) {\n      return arr.concat(v, pointStrings[i]);\n    }, []).join('');\n    d = d.replace(/-0\\./g, '-.').replace(/ 0\\./g, ' .');\n    return d;\n  }\n\n  function initViz() {\n    // force JIT compilation of Viz.js\n    if (this._worker == null) {\n      Viz(\"\");\n\n      this._dispatch.call(\"initEnd\", this);\n    } else {\n      var vizURL = this._vizURL;\n      var graphvizInstance = this;\n\n      this._worker.onmessage = function (event$$1) {\n        graphvizInstance._dispatch.call(\"initEnd\", this);\n      };\n\n      if (!vizURL.match(/^https?:\\/\\/|^\\/\\//i)) {\n        // Local URL. Prepend with local domain to be usable in web worker\n        vizURL = new window.URL(vizURL, document.location.href).href;\n      }\n\n      this._worker.postMessage({\n        dot: \"\",\n        vizURL: vizURL\n      });\n    }\n  }\n\n  var dot = function (src, callback) {\n    var graphvizInstance = this;\n    var worker = this._worker;\n    var engine = this._options.engine;\n    var images = this._images;\n    var totalMemory = this._options.totalMemory;\n    var keyMode = this._options.keyMode;\n    var tweenPaths = this._options.tweenPaths;\n    var tweenShapes = this._options.tweenShapes;\n\n    if (typeof this._options.tweenPrecision == 'string' && this._options.tweenPrecision.includes('%')) {\n      var tweenPrecision = +this._options.tweenPrecision.split('%')[0] / 100;\n\n      var tweenPrecisionIsRelative = this._options.tweenPrecision.includes('%');\n    } else {\n      var tweenPrecision = this._options.tweenPrecision;\n      var tweenPrecisionIsRelative = false;\n    }\n\n    var growEnteringEdges = this._options.growEnteringEdges;\n    var dictionary = {};\n    var prevDictionary = this._dictionary || {};\n    var nodeDictionary = {};\n    var prevNodeDictionary = this._nodeDictionary || {};\n\n    function setKey(datum, index) {\n      var tag = datum.tag;\n\n      if (keyMode == 'index') {\n        datum.key = index;\n      } else if (tag[0] != '#') {\n        if (keyMode == 'id') {\n          datum.key = datum.attributes.id;\n        } else if (keyMode == 'title') {\n          var title = datum.children.find(function (childData) {\n            return childData.tag == 'title';\n          });\n\n          if (title) {\n            if (title.children.length > 0) {\n              datum.key = title.children[0].text;\n            } else {\n              datum.key = '';\n            }\n          }\n        }\n      }\n\n      if (datum.key == null) {\n        if (tweenShapes) {\n          if (tag == 'ellipse' || tag == 'polygon') {\n            tag = 'path';\n          }\n        }\n\n        datum.key = tag + '-' + index;\n      }\n    }\n\n    function setId(datum, parentData) {\n      var id = (parentData ? parentData.id + '.' : '') + datum.key;\n      datum.id = id;\n    }\n\n    function addToDictionary(datum) {\n      dictionary[datum.id] = datum;\n    }\n\n    function calculateAlternativeShapeData(datum, prevDatum) {\n      if (tweenShapes && datum.id in prevDictionary) {\n        if ((prevDatum.tag == 'polygon' || prevDatum.tag == 'ellipse' || prevDatum.tag == 'path') && (prevDatum.tag != datum.tag || datum.tag == 'polygon')) {\n          if (prevDatum.tag != 'path') {\n            datum.alternativeOld = convertToPathData(prevDatum, datum);\n          }\n\n          if (datum.tag != 'path') {\n            datum.alternativeNew = convertToPathData(datum, prevDatum);\n          }\n        }\n      }\n    }\n\n    function calculatePathTweenPoints(datum, prevDatum) {\n      if (tweenPaths && prevDatum && (prevDatum.tag == 'path' || datum.alternativeOld && datum.alternativeOld.tag == 'path')) {\n        var attribute_d = (datum.alternativeNew || datum).attributes.d;\n\n        if (datum.alternativeOld) {\n          var oldNode = createElementWithAttributes(datum.alternativeOld);\n        } else {\n          var oldNode = createElementWithAttributes(prevDatum);\n        }\n\n        (datum.alternativeOld || (datum.alternativeOld = {})).points = pathTweenPoints(oldNode, attribute_d, tweenPrecision, tweenPrecisionIsRelative);\n      }\n    }\n\n    function postProcessDataPass1Local(datum) {\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var parentData = arguments[2];\n      setKey(datum, index);\n      setId(datum, parentData);\n      var id = datum.id;\n      var prevDatum = prevDictionary[id];\n      addToDictionary(datum);\n      calculateAlternativeShapeData(datum, prevDatum);\n      calculatePathTweenPoints(datum, prevDatum);\n      var childTagIndexes = {};\n      datum.children.forEach(function (childData) {\n        var childTag = childData.tag;\n\n        if (childTag == 'ellipse' || childTag == 'polygon') {\n          childTag = 'path';\n        }\n\n        if (childTagIndexes[childTag] == null) {\n          childTagIndexes[childTag] = 0;\n        }\n\n        var childIndex = childTagIndexes[childTag]++;\n        postProcessDataPass1Local(childData, childIndex, datum);\n      });\n    }\n\n    function addToNodeDictionary(datum) {\n      var tag = datum.tag;\n\n      if (growEnteringEdges && datum.parent) {\n        if (datum.parent.attributes.class == 'node') {\n          if (tag == 'title') {\n            if (datum.children.length > 0) {\n              var child = datum.children[0];\n              var nodeId = child.text;\n            } else {\n              var nodeId = '';\n            }\n\n            nodeDictionary[nodeId] = datum.parent;\n          }\n        }\n      }\n    }\n\n    function extractGrowingEdgesData(datum) {\n      var id = datum.id;\n      var tag = datum.tag;\n      var prevDatum = prevDictionary[id];\n\n      if (growEnteringEdges && !prevDatum && datum.parent) {\n        if (isEdgeElement(datum)) {\n          if (tag == 'path' || tag == 'polygon') {\n            if (tag == 'polygon') {\n              var path$$1 = datum.parent.children.find(function (e) {\n                return e.tag == 'path';\n              });\n              datum.totalLength = path$$1.totalLength;\n            }\n\n            var title = getEdgeTitle(datum);\n            var child = title.children[0];\n            var nodeIds = child.text.split('->');\n\n            if (nodeIds.length != 2) {\n              nodeIds = child.text.split('--');\n            }\n\n            var startNodeId = nodeIds[0];\n            var startNode = nodeDictionary[startNodeId];\n            var prevStartNode = prevNodeDictionary[startNodeId];\n\n            if (prevStartNode) {\n              var i = startNode.children.findIndex(function (element, index) {\n                return element.tag == 'g';\n              });\n\n              if (i >= 0) {\n                var j = startNode.children[i].children.findIndex(function (element, index) {\n                  return element.tag == 'a';\n                });\n                startNode = startNode.children[i].children[j];\n              }\n\n              var i = prevStartNode.children.findIndex(function (element, index) {\n                return element.tag == 'g';\n              });\n\n              if (i >= 0) {\n                var j = prevStartNode.children[i].children.findIndex(function (element, index) {\n                  return element.tag == 'a';\n                });\n                prevStartNode = prevStartNode.children[i].children[j];\n              }\n\n              var startShapes = startNode.children;\n\n              for (var i = 0; i < startShapes.length; i++) {\n                if (startShapes[i].tag == 'polygon' || startShapes[i].tag == 'ellipse' || startShapes[i].tag == 'path' || startShapes[i].tag == 'text') {\n                  var startShape = startShapes[i];\n                  break;\n                }\n              }\n\n              var prevStartShapes = prevStartNode.children;\n\n              for (var i = 0; i < prevStartShapes.length; i++) {\n                if (prevStartShapes[i].tag == 'polygon' || prevStartShapes[i].tag == 'ellipse' || prevStartShapes[i].tag == 'path' || prevStartShapes[i].tag == 'text') {\n                  var prevStartShape = prevStartShapes[i];\n                  break;\n                }\n              }\n\n              if (prevStartShape && startShape) {\n                datum.offset = {\n                  x: prevStartShape.center.x - startShape.center.x,\n                  y: prevStartShape.center.y - startShape.center.y\n                };\n              } else {\n                datum.offset = {\n                  x: 0,\n                  y: 0\n                };\n              }\n            }\n          }\n        }\n      }\n    }\n\n    function postProcessDataPass2Global(datum) {\n      addToNodeDictionary(datum);\n      extractGrowingEdgesData(datum);\n      datum.children.forEach(function (childData) {\n        postProcessDataPass2Global(childData);\n      });\n    }\n\n    this._dispatch.call(\"start\", this);\n\n    this._busy = true;\n\n    this._dispatch.call(\"layoutStart\", this);\n\n    var vizOptions = {\n      format: \"svg\",\n      engine: engine,\n      images: images,\n      totalMemory: totalMemory\n    };\n\n    if (this._worker) {\n      worker.postMessage({\n        dot: src,\n        options: vizOptions\n      });\n\n      worker.onmessage = function (event$$1) {\n        switch (event$$1.data.type) {\n          case \"done\":\n            return layoutDone.call(graphvizInstance, event$$1.data.svg);\n\n          case \"error\":\n            if (graphvizInstance._onerror) {\n              graphvizInstance._onerror(event$$1.data.error);\n            } else {\n              throw event$$1.data.error;\n            }\n\n            break;\n        }\n      };\n    } else {\n      try {\n        var svgDoc = Viz(src, vizOptions);\n      } catch (error) {\n        if (graphvizInstance._onerror) {\n          graphvizInstance._onerror(error.message);\n\n          return this;\n        } else {\n          throw error.message;\n        }\n      }\n\n      layoutDone.call(this, svgDoc);\n    }\n\n    function layoutDone(svgDoc) {\n      this._dispatch.call(\"layoutEnd\", this);\n\n      var newDoc = d3.select(document.createDocumentFragment()).append('div');\n      var parser = new window.DOMParser();\n      var doc = parser.parseFromString(svgDoc, \"image/svg+xml\");\n      newDoc.append(function () {\n        return doc.documentElement;\n      });\n      var newSvg = newDoc.select('svg');\n      var data$$1 = extractAllElementsData(newSvg);\n\n      this._dispatch.call('dataExtractEnd', this);\n\n      postProcessDataPass1Local(data$$1);\n\n      this._dispatch.call('dataProcessPass1End', this);\n\n      postProcessDataPass2Global(data$$1);\n\n      this._dispatch.call('dataProcessPass2End', this);\n\n      this._data = data$$1;\n      this._dictionary = dictionary;\n      this._nodeDictionary = nodeDictionary;\n\n      this._extractData = function (element, childIndex, parentData) {\n        var data$$1 = extractAllElementsData(element);\n        postProcessDataPass1Local(data$$1, childIndex, parentData);\n        postProcessDataPass2Global(data$$1);\n        return data$$1;\n      };\n\n      this._busy = false;\n\n      this._dispatch.call('dataProcessEnd', this);\n\n      if (callback) {\n        callback.call(this);\n      }\n\n      if (this._queue.length > 0) {\n        var job = this._queue.shift();\n\n        job.call(this);\n      }\n    }\n\n    return this;\n  };\n\n  var renderDot = function (src, callback) {\n    var graphvizInstance = this;\n    this.dot(src, render);\n\n    function render() {\n      graphvizInstance.render(callback);\n    }\n\n    return this;\n  };\n\n  var transition$1 = function (name) {\n    if (name instanceof Function) {\n      this._transitionFactory = name;\n    } else {\n      this._transition = d3Transition.transition(name);\n    }\n\n    return this;\n  };\n\n  function active$1(name) {\n    var root = this._selection;\n    var svg = root.selectWithoutDataPropagation(\"svg\");\n\n    if (svg.size() != 0) {\n      return d3Transition.active(svg.node(), name);\n    } else {\n      return null;\n    }\n  }\n\n  var options = function (options) {\n    if (typeof options == 'undefined') {\n      return Object.assign({}, this._options);\n    } else {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = Object.keys(options)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var option = _step.value;\n          this._options[option] = options[option];\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return this;\n    }\n  };\n\n  var width = function (width) {\n    this._options.width = width;\n    return this;\n  };\n\n  var height = function (height) {\n    this._options.height = height;\n    return this;\n  };\n\n  var scale = function (scale) {\n    this._options.scale = scale;\n    return this;\n  };\n\n  var fit = function (fit) {\n    this._options.fit = fit;\n    return this;\n  };\n\n  var attributer = function (callback) {\n    this._attributer = callback;\n    return this;\n  };\n\n  var engine = function (engine) {\n    this._options.engine = engine;\n    return this;\n  };\n\n  var images = function (path$$1, width, height) {\n    this._images.push({\n      path: path$$1,\n      width: width,\n      height: height\n    });\n\n    return this;\n  };\n\n  var totalMemory = function (size) {\n    this._options.totalMemory = size;\n    return this;\n  };\n\n  var keyMode = function (keyMode) {\n    if (!this._keyModes.has(keyMode)) {\n      throw Error('Illegal keyMode: ' + keyMode);\n    }\n\n    if (keyMode != this._options.keyMode && this._data != null) {\n      throw Error('Too late to change keyMode');\n    }\n\n    this._options.keyMode = keyMode;\n    return this;\n  };\n\n  var fade = function (enable) {\n    this._options.fade = enable;\n    return this;\n  };\n\n  var tweenPaths = function (enable) {\n    this._options.tweenPaths = enable;\n    return this;\n  };\n\n  var tweenShapes = function (enable) {\n    this._options.tweenShapes = enable;\n\n    if (enable) {\n      this._options.tweenPaths = true;\n    }\n\n    return this;\n  };\n\n  var convertEqualSidedPolygons = function (enable) {\n    this._options.convertEqualSidedPolygons = enable;\n    return this;\n  };\n\n  var tweenPrecision = function (precision) {\n    this._options.tweenPrecision = precision;\n    return this;\n  };\n\n  var growEnteringEdges = function (enable) {\n    this._options.growEnteringEdges = enable;\n    return this;\n  };\n\n  var on = function (typenames, callback) {\n    this._dispatch.on(typenames, callback);\n\n    return this;\n  };\n\n  var onerror = function (callback) {\n    this._onerror = callback;\n    return this;\n  };\n\n  var defineProperty = function (obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  };\n\n  var toConsumableArray = function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  };\n\n  var logEvents = function (enable) {\n    var _this = this;\n\n    var t0 = Date.now();\n    var times = {};\n    var eventTypes = this._eventTypes;\n    var maxEventTypeLength = Math.max.apply(Math, toConsumableArray(eventTypes.map(function (eventType) {\n      return eventType.length;\n    })));\n\n    var _loop = function _loop(i) {\n      var eventType = eventTypes[i];\n      times[eventType] = [];\n      graphvizInstance = _this;\n\n      _this.on(eventType + '.log', enable ? function () {\n        var t = Date.now();\n        var seqNo = times[eventType].length;\n        times[eventType].push(t);\n        var string = '';\n        string += 'Event ';\n        string += d3Format.format(' >2')(i) + ' ';\n        string += eventType + ' '.repeat(maxEventTypeLength - eventType.length);\n        string += d3Format.format(' >5')(t - t0) + ' ';\n\n        if (eventType != 'initEnd') {\n          string += d3Format.format(' >5')(t - times['start'][seqNo]);\n        }\n\n        if (eventType == 'dataProcessEnd') {\n          string += ' prepare                 ' + d3Format.format(' >5')(t - times['layoutEnd'][seqNo]);\n        }\n\n        if (eventType == 'renderEnd' && graphvizInstance._transition) {\n          string += ' transition start margin ' + d3Format.format(' >5')(graphvizInstance._transition.delay() - (t - times['renderStart'][seqNo]));\n          expectedDelay = graphvizInstance._transition.delay();\n          expectedDuration = graphvizInstance._transition.duration();\n        }\n\n        if (eventType == 'transitionStart') {\n          var actualDelay = t - times['renderStart'][seqNo];\n          string += ' transition delay        ' + d3Format.format(' >5')(t - times['renderStart'][seqNo]);\n          string += ' expected ' + d3Format.format(' >5')(expectedDelay);\n          string += ' diff ' + d3Format.format(' >5')(actualDelay - expectedDelay);\n        }\n\n        if (eventType == 'transitionEnd') {\n          var actualDuration = t - times['transitionStart'][seqNo];\n          string += ' transition duration     ' + d3Format.format(' >5')(actualDuration);\n          string += ' expected ' + d3Format.format(' >5')(expectedDuration);\n          string += ' diff ' + d3Format.format(' >5')(actualDuration - expectedDuration);\n        }\n\n        console.log(string);\n        t0 = t;\n      } : null);\n    };\n\n    for (var i in eventTypes) {\n      var graphvizInstance;\n      var expectedDelay;\n      var expectedDuration;\n\n      _loop(i);\n    }\n\n    return this;\n  };\n\n  function rotate(x, y, cosA, sinA) {\n    // (x + j * y) * (cosA + j * sinA) = x * cosA - y * sinA + j * (x * sinA + y * cosA)\n    y = -y;\n    sinA = -sinA;\n    var _ref = [x * cosA - y * sinA, x * sinA + y * cosA];\n    x = _ref[0];\n    y = _ref[1];\n    y = -y;\n    return [x, y];\n  }\n\n  function drawEdge(x1, y1, x2, y2, attributes) {\n    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    attributes = Object.assign({}, attributes);\n\n    if (attributes.style && attributes.style.includes('invis')) {\n      var newEdge = d3.select(null);\n    } else {\n      var root = this._selection;\n      var svg = root.selectWithoutDataPropagation(\"svg\");\n      var graph0 = svg.selectWithoutDataPropagation(\"g\");\n      var newEdge0 = createEdge(attributes);\n      var edgeData = extractAllElementsData(newEdge0);\n      var newEdge = graph0.append('g').data([edgeData]);\n      attributeElement.call(newEdge.node(), edgeData);\n\n      _updateEdge(newEdge, x1, y1, x2, y2, attributes, options);\n    }\n\n    this._drawnEdge = {\n      g: newEdge,\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      attributes: attributes\n    };\n    return this;\n  }\n\n  function updateDrawnEdge(x1, y1, x2, y2) {\n    var attributes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n    if (!this._drawnEdge) {\n      throw Error('No edge has been drawn');\n    }\n\n    var edge = this._drawnEdge.g;\n    attributes = Object.assign(this._drawnEdge.attributes, attributes);\n    this._drawnEdge.x1 = x1;\n    this._drawnEdge.y1 = y1;\n    this._drawnEdge.x2 = x2;\n    this._drawnEdge.y2 = y2;\n\n    if (edge.empty() && !(attributes.style && attributes.style.includes('invis'))) {\n      var root = this._selection;\n      var svg = root.selectWithoutDataPropagation(\"svg\");\n      var graph0 = svg.selectWithoutDataPropagation(\"g\");\n      var edge = graph0.append('g');\n      this._drawnEdge.g = edge;\n    }\n\n    if (!edge.empty()) {\n      _updateEdge(edge, x1, y1, x2, y2, attributes, options);\n    }\n\n    return this;\n  }\n\n  function _updateEdge(edge, x1, y1, x2, y2, attributes, options) {\n    var newEdge = createEdge(attributes);\n    var edgeData = extractAllElementsData(newEdge);\n    edge.data([edgeData]);\n    attributeElement.call(edge.node(), edgeData);\n\n    _moveEdge(edge, x1, y1, x2, y2, attributes, options);\n  }\n\n  function _moveEdge(edge, x1, y1, x2, y2, attributes, options) {\n    var shortening = options.shortening || 0;\n    var arrowHeadLength = 10;\n    var arrowHeadWidth = 7;\n    var margin = 0.174;\n    var arrowHeadPoints = [[0, -arrowHeadWidth / 2], [arrowHeadLength, 0], [0, arrowHeadWidth / 2], [0, -arrowHeadWidth / 2]];\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    var length = Math.sqrt(dx * dx + dy * dy);\n\n    if (length == 0) {\n      var cosA = 1;\n      var sinA = 0;\n    } else {\n      var cosA = dx / length;\n      var sinA = dy / length;\n    }\n\n    x2 = x1 + (length - shortening - arrowHeadLength - margin) * cosA;\n    y2 = y1 + (length - shortening - arrowHeadLength - margin) * sinA;\n\n    if (attributes.URL || attributes.tooltip) {\n      var a = edge.selectWithoutDataPropagation(\"g\").selectWithoutDataPropagation(\"a\");\n      var line = a.selectWithoutDataPropagation(\"path\");\n      var arrowHead = a.selectWithoutDataPropagation(\"polygon\");\n    } else {\n      var line = edge.selectWithoutDataPropagation(\"path\");\n      var arrowHead = edge.selectWithoutDataPropagation(\"polygon\");\n    }\n\n    var path1 = d3Path.path();\n    path1.moveTo(x1, y1);\n    path1.lineTo(x2, y2);\n    line.attr(\"d\", path1);\n    x2 = x1 + (length - shortening - arrowHeadLength) * cosA;\n    y2 = y1 + (length - shortening - arrowHeadLength) * sinA;\n\n    for (var i = 0; i < arrowHeadPoints.length; i++) {\n      var point = arrowHeadPoints[i];\n      arrowHeadPoints[i] = rotate(point[0], point[1], cosA, sinA);\n    }\n\n    for (var i = 0; i < arrowHeadPoints.length; i++) {\n      var point = arrowHeadPoints[i];\n      arrowHeadPoints[i] = [x2 + point[0], y2 + point[1]];\n    }\n\n    var allPoints = [];\n\n    for (var i = 0; i < arrowHeadPoints.length; i++) {\n      var point = arrowHeadPoints[i];\n      allPoints.push(point.join(','));\n    }\n\n    var pointsAttr = allPoints.join(' ');\n    arrowHead.attr(\"points\", pointsAttr);\n    return this;\n  }\n\n  function moveDrawnEdgeEndPoint(x2, y2) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!this._drawnEdge) {\n      throw Error('No edge has been drawn');\n    }\n\n    var edge = this._drawnEdge.g;\n    var x1 = this._drawnEdge.x1;\n    var y1 = this._drawnEdge.y1;\n    var attributes = this._drawnEdge.attributes;\n    this._drawnEdge.x2 = x2;\n    this._drawnEdge.y2 = y2;\n\n    _moveEdge(edge, x1, y1, x2, y2, attributes, options);\n\n    return this;\n  }\n\n  function removeDrawnEdge() {\n    if (!this._drawnEdge) {\n      return this;\n    }\n\n    var edge = this._drawnEdge.g;\n    edge.remove();\n    this._drawnEdge = null;\n    return this;\n  }\n\n  function insertDrawnEdge(name) {\n    if (!this._drawnEdge) {\n      throw Error('No edge has been drawn');\n    }\n\n    var edge = this._drawnEdge.g;\n\n    if (edge.empty()) {\n      return this;\n    }\n\n    var attributes = this._drawnEdge.attributes;\n    var title = edge.selectWithoutDataPropagation(\"title\");\n    title.text(name);\n    var root = this._selection;\n    var svg = root.selectWithoutDataPropagation(\"svg\");\n    var graph0 = svg.selectWithoutDataPropagation(\"g\");\n    var graph0Datum = graph0.datum();\n\n    var edgeData = this._extractData(edge, graph0Datum.children.length, graph0.datum());\n\n    graph0Datum.children.push(edgeData);\n    insertAllElementsData(edge, edgeData);\n    this._drawnEdge = null;\n    return this;\n  }\n\n  function drawnEdgeSelection() {\n    if (this._drawnEdge) {\n      return this._drawnEdge.g;\n    } else {\n      return d3.select(null);\n    }\n  }\n\n  function createEdge(attributes) {\n    var attributesString = '';\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = Object.keys(attributes)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var name = _step.value;\n\n        if (attributes[name] != null) {\n          attributesString += ' \"' + name + '\"=\"' + attributes[name] + '\"';\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var dotSrc = 'digraph {a -> b [' + attributesString + ']}';\n    var svgDoc = Viz(dotSrc, {\n      format: 'svg'\n    });\n    var parser = new window.DOMParser();\n    var doc = parser.parseFromString(svgDoc, \"image/svg+xml\");\n    var newDoc = d3.select(document.createDocumentFragment()).append(function () {\n      return doc.documentElement;\n    });\n    var edge = newDoc.select('.edge');\n    return edge;\n  }\n\n  function drawNode(x, y, nodeId) {\n    var attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    attributes = Object.assign({}, attributes);\n\n    if (attributes.style && attributes.style.includes('invis')) {\n      var newNode = d3.select(null);\n    } else {\n      var root = this._selection;\n      var svg = root.selectWithoutDataPropagation(\"svg\");\n      var graph0 = svg.selectWithoutDataPropagation(\"g\");\n      var newNode0 = createNode(nodeId, attributes);\n      var nodeData = extractAllElementsData(newNode0);\n      var newNode = graph0.append('g').data([nodeData]);\n      attributeElement.call(newNode.node(), nodeData);\n\n      _updateNode(newNode, x, y, nodeId, attributes, options);\n    }\n\n    this._drawnNode = {\n      g: newNode,\n      nodeId: nodeId,\n      x: x,\n      y: y,\n      attributes: attributes\n    };\n    return this;\n  }\n\n  function updateDrawnNode(x, y, nodeId) {\n    var attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n    if (!this._drawnNode) {\n      throw Error('No node has been drawn');\n    }\n\n    var node = this._drawnNode.g;\n\n    if (nodeId == null) {\n      nodeId = this._drawnNode.nodeId;\n    }\n\n    attributes = Object.assign(this._drawnNode.attributes, attributes);\n    this._drawnNode.nodeId = nodeId;\n    this._drawnNode.x = x;\n    this._drawnNode.y = y;\n\n    if (node.empty() && !(attributes.style && attributes.style.includes('invis'))) {\n      var root = this._selection;\n      var svg = root.selectWithoutDataPropagation(\"svg\");\n      var graph0 = svg.selectWithoutDataPropagation(\"g\");\n      var node = graph0.append('g');\n      this._drawnNode.g = node;\n    }\n\n    if (!node.empty()) {\n      _updateNode(node, x, y, nodeId, attributes, options);\n    }\n\n    return this;\n  }\n\n  function _updateNode(node, x, y, nodeId, attributes, options) {\n    var newNode = createNode(nodeId, attributes);\n    var nodeData = extractAllElementsData(newNode);\n    node.data([nodeData]);\n    attributeElement.call(node.node(), nodeData);\n\n    _moveNode(node, x, y, attributes, options);\n\n    return this;\n  }\n\n  function _moveNode(node, x, y, attributes, options) {\n    if (attributes.URL || attributes.tooltip) {\n      var subParent = node.selectWithoutDataPropagation(\"g\").selectWithoutDataPropagation(\"a\");\n    } else {\n      var subParent = node;\n    }\n\n    var svgElements = subParent.selectAll('ellipse,polygon,path,polyline');\n    var text = node.selectWithoutDataPropagation(\"text\");\n\n    if (svgElements.size() != 0) {\n      var bbox = svgElements.node().getBBox();\n      bbox.cx = bbox.x + bbox.width / 2;\n      bbox.cy = bbox.y + bbox.height / 2;\n    } else if (text.size() != 0) {\n      bbox = {\n        x: +text.attr('x'),\n        y: +text.attr('y'),\n        width: 0,\n        height: 0,\n        cx: +text.attr('x'),\n        cy: +text.attr('y')\n      };\n    }\n\n    svgElements.each(function (data, index) {\n      var svgElement = d3.select(this);\n\n      if (svgElement.attr(\"cx\")) {\n        svgElement.attr(\"cx\", roundTo4Decimals(x)).attr(\"cy\", roundTo4Decimals(y));\n      } else if (svgElement.attr(\"points\")) {\n        var pointsString = svgElement.attr('points').trim();\n        svgElement.attr(\"points\", translatePointsAttribute(pointsString, x - bbox.cx, y - bbox.cy));\n      } else {\n        var d = svgElement.attr('d');\n        svgElement.attr(\"d\", translateDAttribute(d, x - bbox.cx, y - bbox.cy));\n      }\n    });\n\n    if (text.size() != 0) {\n      text.attr(\"x\", roundTo4Decimals(+text.attr(\"x\") + x - bbox.cx)).attr(\"y\", roundTo4Decimals(+text.attr(\"y\") + y - bbox.cy));\n    }\n\n    return this;\n  }\n\n  function moveDrawnNode(x, y) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!this._drawnNode) {\n      throw Error('No node has been drawn');\n    }\n\n    var node = this._drawnNode.g;\n    var attributes = this._drawnNode.attributes;\n    this._drawnNode.x = x;\n    this._drawnNode.y = y;\n\n    if (!node.empty()) {\n      _moveNode(node, x, y, attributes, options);\n    }\n\n    return this;\n  }\n\n  function removeDrawnNode() {\n    if (!this._drawnNode) {\n      return this;\n    }\n\n    var node = this._drawnNode.g;\n\n    if (!node.empty()) {\n      node.remove();\n    }\n\n    this._drawnNode = null;\n    return this;\n  }\n\n  function insertDrawnNode(nodeId) {\n    if (!this._drawnNode) {\n      throw Error('No node has been drawn');\n    }\n\n    if (nodeId == null) {\n      nodeId = this._drawnNode.nodeId;\n    }\n\n    var node = this._drawnNode.g;\n\n    if (node.empty()) {\n      return this;\n    }\n\n    var attributes = this._drawnNode.attributes;\n    var title = node.selectWithoutDataPropagation(\"title\");\n    title.text(nodeId);\n\n    if (attributes.URL || attributes.tooltip) {\n      var ga = node.selectWithoutDataPropagation(\"g\");\n      var a = ga.selectWithoutDataPropagation(\"a\");\n      var svgElement = a.selectWithoutDataPropagation('ellipse,polygon,path,polyline');\n      var text = a.selectWithoutDataPropagation('text');\n    } else {\n      var svgElement = node.selectWithoutDataPropagation('ellipse,polygon,path,polyline');\n      var text = node.selectWithoutDataPropagation('text');\n    }\n\n    text.text(attributes.label || nodeId);\n    var root = this._selection;\n    var svg = root.selectWithoutDataPropagation(\"svg\");\n    var graph0 = svg.selectWithoutDataPropagation(\"g\");\n    var graph0Datum = graph0.datum();\n\n    var nodeData = this._extractData(node, graph0Datum.children.length, graph0.datum());\n\n    graph0Datum.children.push(nodeData);\n    insertAllElementsData(node, nodeData);\n    this._drawnNode = null;\n    return this;\n  }\n\n  function drawnNodeSelection() {\n    if (this._drawnNode) {\n      return this._drawnNode.g;\n    } else {\n      return d3.select(null);\n    }\n  }\n\n  function createNode(nodeId, attributes) {\n    var attributesString = '';\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = Object.keys(attributes)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var name = _step.value;\n\n        if (attributes[name] != null) {\n          attributesString += ' \"' + name + '\"=\"' + attributes[name] + '\"';\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var dotSrc = 'graph {\"' + nodeId + '\" [' + attributesString + ']}';\n    var svgDoc = Viz(dotSrc, {\n      format: 'svg'\n    });\n    var parser = new window.DOMParser();\n    var doc = parser.parseFromString(svgDoc, \"image/svg+xml\");\n    var newDoc = d3.select(document.createDocumentFragment()).append(function () {\n      return doc.documentElement;\n    });\n    var node = newDoc.select('.node');\n    return node;\n  }\n\n  var _graphviz$prototype;\n\n  function Graphviz(selection$$1, options$$1) {\n    this._options = {\n      useWorker: true,\n      engine: 'dot',\n      totalMemory: undefined,\n      keyMode: 'title',\n      fade: true,\n      tweenPaths: true,\n      tweenShapes: true,\n      convertEqualSidedPolygons: true,\n      tweenPrecision: 1,\n      growEnteringEdges: true,\n      zoom: true,\n      zoomScaleExtent: [0.1, 10],\n      zoomTranslateExtent: [[-Infinity, -Infinity], [+Infinity, +Infinity]],\n      width: null,\n      height: null,\n      scale: 1,\n      fit: false\n    };\n\n    if (options$$1 instanceof Object) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = Object.keys(options$$1)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var option = _step.value;\n          this._options[option] = options$$1[option];\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    } else if (typeof options$$1 == 'boolean') {\n      this._options.useWorker = options$$1;\n    }\n\n    var useWorker = this._options.useWorker;\n\n    if (typeof Worker == 'undefined') {\n      useWorker = false;\n    }\n\n    if (useWorker) {\n      var scripts = d3.selectAll('script');\n      var vizScript = scripts.filter(function () {\n        return d3.select(this).attr('type') == 'javascript/worker' || d3.select(this).attr('src') && d3.select(this).attr('src').match(/.*\\/viz.js$/);\n      });\n\n      if (vizScript.size() == 0) {\n        console.warn('No script tag of type \"javascript/worker\" was found and \"useWorker\" is true. Not using web worker.');\n        useWorker = false;\n      } else {\n        this._vizURL = vizScript.attr('src');\n\n        if (!this._vizURL) {\n          console.warn('No \"src\" attribute of was found on the \"javascript/worker\" script tag and \"useWorker\" is true. Not using web worker.');\n          useWorker = false;\n        }\n      }\n    }\n\n    if (useWorker) {\n      var js = \"\\n            onmessage = function(event) {\\n                if (event.data.vizURL) {\\n                    importScripts(event.data.vizURL);\\n                }\\n                try {\\n                    var svg = Viz(event.data.dot, event.data.options);\\n                }\\n                catch(error) {\\n                    postMessage({\\n                        type: \\\"error\\\",\\n                        error: error.message,\\n                    });\\n                    return;\\n                }\\n                if (svg) {\\n                    postMessage({\\n                        type: \\\"done\\\",\\n                        svg: svg,\\n                    });\\n                } else {\\n                    postMessage({\\n                        type: \\\"skip\\\",\\n                    });\\n                }\\n            }\\n        \";\n      var blob = new Blob([js]);\n      var blobURL = window.URL.createObjectURL(blob);\n      this._worker = new Worker(blobURL);\n    }\n\n    this._selection = selection$$1;\n    this._active = false;\n    this._busy = false;\n    this._jobs = [];\n    this._queue = [];\n    this._keyModes = new Set(['title', 'id', 'tag-index', 'index']);\n    this._images = [];\n    this._translation = undefined;\n    this._scale = undefined;\n    this._eventTypes = ['initEnd', 'start', 'layoutStart', 'layoutEnd', 'dataExtractEnd', 'dataProcessPass1End', 'dataProcessPass2End', 'dataProcessEnd', 'renderStart', 'renderEnd', 'transitionStart', 'transitionEnd', 'restoreEnd', 'end'];\n    this._dispatch = d3Dispatch.dispatch.apply(undefined, toConsumableArray(this._eventTypes));\n    initViz.call(this);\n    selection$$1.node().__graphviz__ = this;\n  }\n\n  function graphviz(selector, options$$1) {\n    var g = d3.select(selector).graphviz(options$$1);\n    return g;\n  }\n\n  Graphviz.prototype = graphviz.prototype = (_graphviz$prototype = {\n    constructor: Graphviz,\n    engine: engine,\n    addImage: images,\n    totalMemory: totalMemory,\n    keyMode: keyMode,\n    fade: fade,\n    tweenPaths: tweenPaths,\n    tweenShapes: tweenShapes,\n    convertEqualSidedPolygons: convertEqualSidedPolygons,\n    tweenPrecision: tweenPrecision,\n    growEnteringEdges: growEnteringEdges,\n    zoom: zoom$1,\n    resetZoom: resetZoom,\n    zoomBehavior: zoomBehavior,\n    zoomSelection: zoomSelection,\n    zoomScaleExtent: zoomScaleExtent,\n    zoomTranslateExtent: zoomTranslateExtent,\n    render: render,\n    dot: dot,\n    data: data,\n    renderDot: renderDot,\n    transition: transition$1,\n    active: active$1,\n    options: options,\n    width: width,\n    height: height,\n    scale: scale,\n    fit: fit,\n    attributer: attributer,\n    on: on,\n    onerror: onerror,\n    logEvents: logEvents,\n    drawEdge: drawEdge,\n    updateDrawnEdge: updateDrawnEdge,\n    moveDrawnEdgeEndPoint: moveDrawnEdgeEndPoint,\n    insertDrawnEdge: insertDrawnEdge,\n    removeDrawnEdge: removeDrawnEdge\n  }, defineProperty(_graphviz$prototype, \"removeDrawnEdge\", removeDrawnEdge), defineProperty(_graphviz$prototype, \"drawnEdgeSelection\", drawnEdgeSelection), defineProperty(_graphviz$prototype, \"drawnEdgeSelection\", drawnEdgeSelection), defineProperty(_graphviz$prototype, \"drawNode\", drawNode), defineProperty(_graphviz$prototype, \"updateDrawnNode\", updateDrawnNode), defineProperty(_graphviz$prototype, \"moveDrawnNode\", moveDrawnNode), defineProperty(_graphviz$prototype, \"insertDrawnNode\", insertDrawnNode), defineProperty(_graphviz$prototype, \"removeDrawnNode\", removeDrawnNode), defineProperty(_graphviz$prototype, \"removeDrawnNode\", removeDrawnNode), defineProperty(_graphviz$prototype, \"drawnNodeSelection\", drawnNodeSelection), defineProperty(_graphviz$prototype, \"drawnNodeSelection\", drawnNodeSelection), _graphviz$prototype);\n\n  var selection_graphviz = function (options) {\n    var g = this.node().__graphviz__;\n\n    if (g) {\n      g.options(options);\n\n      g._dispatch.call(\"initEnd\", this);\n    } else {\n      g = new Graphviz(this, options);\n    }\n\n    return g;\n  };\n\n  var selection_selectWithoutDataPropagation = function (name) {\n    return d3.select(this.size() > 0 ? this.node().querySelector(name) : null);\n  };\n\n  d3.selection.prototype.graphviz = selection_graphviz;\n  d3.selection.prototype.selectWithoutDataPropagation = selection_selectWithoutDataPropagation;\n  exports.graphviz = graphviz;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}